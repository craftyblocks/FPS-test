<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Simple FPS</title>
  <style>
    body {
      margin: 0;
      overflow: hidden;
      background: #000;
      color: white;
      font-family: sans-serif;
    }
    #overlay {
      position: fixed;
      inset: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      background: rgba(0,0,0,0.8);
      cursor: pointer;
      z-index: 10;
    }
    #crosshair {
      position: fixed;
      top: 50%;
      left: 50%;
      width: 10px;
      height: 10px;
      margin-left: -5px;
      margin-top: -5px;
      border: 2px solid white;
      border-radius: 50%;
      pointer-events: none;
      z-index: 5;
    }
    #info {
      position: fixed;
      top: 10px;
      left: 10px;
      z-index: 5;
      font-size: 14px;
    }
  </style>
</head>
<body>
  <div id="overlay">
    <div>Click to start (WASD to move, mouse to look, left click to shoot)</div>
  </div>
  <div id="crosshair"></div>
  <div id="info"></div>

  <!-- Three.js from CDN -->
  <script type="module">
    import * as THREE from "https://unpkg.com/three@0.160.0/build/three.module.js";
    import { PointerLockControls } from "https://unpkg.com/three@0.160.0/examples/jsm/controls/PointerLockControls.js";

    let scene, camera, renderer, controls;
    let moveForward = false, moveBackward = false, moveLeft = false, moveRight = false;
    let velocity = new THREE.Vector3();
    let direction = new THREE.Vector3();
    let bots = [];
    let bullets = [];
    let clock = new THREE.Clock();
    let wave = 1;
    let aliveBots = 0;

    const infoEl = document.getElementById("info");
    const overlay = document.getElementById("overlay");

    init();
    animate();

    function init() {
      scene = new THREE.Scene();
      scene.background = new THREE.Color(0x202030);

      camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
      camera.position.set(0, 1.6, 5);

      renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      document.body.appendChild(renderer.domElement);

      // Light
      const hemi = new THREE.HemisphereLight(0xffffff, 0x444444, 1.0);
      hemi.position.set(0, 20, 0);
      scene.add(hemi);

      const dirLight = new THREE.DirectionalLight(0xffffff, 0.5);
      dirLight.position.set(5, 10, 2);
      scene.add(dirLight);

      // Floor
      const floorGeo = new THREE.PlaneGeometry(100, 100);
      const floorMat = new THREE.MeshStandardMaterial({ color: 0x303030 });
      const floor = new THREE.Mesh(floorGeo, floorMat);
      floor.rotation.x = -Math.PI / 2;
      scene.add(floor);

      // Simple walls / boxes
      const boxGeo = new THREE.BoxGeometry(2, 2, 2);
      const boxMat = new THREE.MeshStandardMaterial({ color: 0x555555 });
      for (let i = 0; i < 10; i++) {
        const box = new THREE.Mesh(boxGeo, boxMat);
        box.position.set(
          (Math.random() - 0.5) * 40,
          1,
          (Math.random() - 0.5) * 40
        );
        scene.add(box);
      }

      // Pointer lock controls
      controls = new PointerLockControls(camera, document.body);

      overlay.addEventListener("click", () => {
        controls.lock();
      });

      controls.addEventListener("lock", () => {
        overlay.style.display = "none";
      });

      controls.addEventListener("unlock", () => {
        overlay.style.display = "flex";
      });

      // Gun (simple box in front of camera)
      const gunGeo = new THREE.BoxGeometry(0.2, 0.2, 0.8);
      const gunMat = new THREE.MeshStandardMaterial({ color: 0x2222ff });
      const gun = new THREE.Mesh(gunGeo, gunMat);
      gun.position.set(0.3, -0.3, -0.8);
      gun.castShadow = true;
      camera.add(gun);
      scene.add(camera);

      // Events
      const onKeyDown = (event) => {
        switch (event.code) {
          case "KeyW":
          case "ArrowUp":
            moveForward = true;
            break;
          case "KeyS":
          case "ArrowDown":
            moveBackward = true;
            break;
          case "KeyA":
          case "ArrowLeft":
            moveLeft = true;
            break;
          case "KeyD":
          case "ArrowRight":
            moveRight = true;
            break;
        }
      };

      const onKeyUp = (event) => {
        switch (event.code) {
          case "KeyW":
          case "ArrowUp":
            moveForward = false;
            break;
          case "KeyS":
          case "ArrowDown":
            moveBackward = false;
            break;
          case "KeyA":
          case "ArrowLeft":
            moveLeft = false;
            break;
          case "KeyD":
          case "ArrowRight":
            moveRight = false;
            break;
        }
      };

      document.addEventListener("keydown", onKeyDown);
      document.addEventListener("keyup", onKeyUp);

      // Shooting
      document.addEventListener("mousedown", (event) => {
        if (event.button === 0 && controls.isLocked) {
          shoot();
        }
      });

      window.addEventListener("resize", onWindowResize);

      spawnWave();
    }

    function onWindowResize() {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    }

    function spawnWave() {
      const count = 3 + wave * 2;
      bots.forEach(b => scene.remove(b.mesh));
      bots = [];
      aliveBots = count;

      const botGeo = new THREE.BoxGeometry(1, 1.8, 1);
      const botMat = new THREE.MeshStandardMaterial({ color: 0xff3333 });

      for (let i = 0; i < count; i++) {
        const mesh = new THREE.Mesh(botGeo, botMat);
        mesh.position.set(
          (Math.random() - 0.5) * 40,
          0.9,
          (Math.random() - 0.5) * 40
        );
        scene.add(mesh);
        bots.push({
          mesh,
          hp: 3,
        });
      }
    }

    function shoot() {
      // Visual bullet (small sphere)
      const bulletGeo = new THREE.SphereGeometry(0.05, 8, 8);
      const bulletMat = new THREE.MeshBasicMaterial({ color: 0xffff00 });
      const bullet = new THREE.Mesh(bulletGeo, bulletMat);

      const start = new THREE.Vector3();
      const dir = new THREE.Vector3();
      camera.getWorldPosition(start);
      camera.getWorldDirection(dir);

      bullet.position.copy(start).add(dir.clone().multiplyScalar(0.5));
      bullet.userData.velocity = dir.clone().multiplyScalar(80);
      bullet.userData.life = 1.0; // seconds

      scene.add(bullet);
      bullets.push(bullet);

      // Raycast for instant hit
      const raycaster = new THREE.Raycaster(start, dir);
      const botMeshes = bots.map(b => b.mesh);
      const intersects = raycaster.intersectObjects(botMeshes, false);
      if (intersects.length > 0) {
        const hit = intersects[0].object;
        const bot = bots.find(b => b.mesh === hit);
        if (bot) {
          bot.hp -= 1;
          hit.material.color.setHex(0xffaaaa);
          if (bot.hp <= 0) {
            scene.remove(bot.mesh);
            bots = bots.filter(b => b !== bot);
            aliveBots--;
            if (aliveBots <= 0) {
              wave++;
              spawnWave();
            }
          }
        }
      }
    }

    function updateBullets(delta) {
      for (let i = bullets.length - 1; i >= 0; i--) {
        const b = bullets[i];
        b.position.add(b.userData.velocity.clone().multiplyScalar(delta));
        b.userData.life -= delta;
        if (b.userData.life <= 0) {
          scene.remove(b);
          bullets.splice(i, 1);
        }
      }
    }

    function updateBots(delta) {
      const playerPos = new THREE.Vector3();
      camera.getWorldPosition(playerPos);

      bots.forEach(bot => {
        const pos = bot.mesh.position;
        const dir = playerPos.clone().sub(pos);
        const dist = dir.length();
        if (dist > 0.1) {
          dir.normalize();
          const speed = 2;
          pos.add(dir.multiplyScalar(speed * delta));
        }
      });
    }

    function animate() {
      requestAnimationFrame(animate);

      const delta = clock.getDelta();

      if (controls.isLocked) {
        // Movement
        velocity.x -= velocity.x * 10.0 * delta;
        velocity.z -= velocity.z * 10.0 * delta;

        direction.z = Number(moveForward) - Number(moveBackward);
        direction.x = Number(moveRight) - Number(moveLeft);
        direction.normalize();

        const speed = 10.0;

        if (moveForward || moveBackward) velocity.z -= direction.z * speed * delta;
        if (moveLeft || moveRight) velocity.x -= direction.x * speed * delta;

        controls.moveRight(-velocity.x * delta);
        controls.moveForward(-velocity.z * delta);
      }

      updateBullets(delta);
      updateBots(delta);

      infoEl.textContent = `Wave: ${wave} | Bots alive: ${aliveBots}`;

      renderer.render(scene, camera);
    }
  </script>
</body>
</html>
